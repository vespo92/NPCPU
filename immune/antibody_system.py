"""
Antibody System

Generates adaptive responses to threats. Implements biological-inspired
antibody generation and selection mechanisms:
- Clonal selection (amplify successful responses)
- Somatic hypermutation (evolve better responses)
- Affinity maturation (improve binding over time)
"""

import time
import uuid
import random
from typing import List, Dict, Any, Optional, Callable, Set, Tuple
from dataclasses import dataclass, field
from enum import Enum
from collections import defaultdict
import numpy as np

import sys
import os
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))

from immune.defense import Threat, ThreatType, ThreatSeverity


# ============================================================================
# Enums
# ============================================================================

class AntibodyState(Enum):
    """States of an antibody"""
    NAIVE = "naive"           # Never activated
    ACTIVATED = "activated"   # Currently active
    MEMORY = "memory"         # Stored for future use
    EFFECTOR = "effector"     # Actively neutralizing
    EXHAUSTED = "exhausted"   # Overused, needs rest
    RETIRED = "retired"       # No longer effective


class ResponseType(Enum):
    """Types of immune responses"""
    NEUTRALIZE = "neutralize"       # Directly block threat
    OPSONIZE = "opsonize"           # Mark for destruction
    COMPLEMENT = "complement"        # Activate cascade destruction
    SIGNAL = "signal"               # Alert other systems
    MEMORY = "memory"               # Remember for future


class BindingStrength(Enum):
    """Antibody-antigen binding strength"""
    NONE = 0
    WEAK = 1
    MODERATE = 2
    STRONG = 3
    VERY_STRONG = 4
    PERFECT = 5


# ============================================================================
# Data Structures
# ============================================================================

@dataclass
class Antigen:
    """Represents a threat antigen (signature)"""
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    threat_type: ThreatType = ThreatType.ANOMALY
    signature: str = ""
    epitopes: List[str] = field(default_factory=list)  # Binding sites
    virulence: float = 0.5  # How dangerous (0-1)
    first_seen: float = field(default_factory=time.time)
    encounter_count: int = 1


@dataclass
class Antibody:
    """A digital antibody for threat neutralization"""
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    name: str = ""
    target_types: Set[ThreatType] = field(default_factory=set)
    binding_pattern: str = ""
    paratope: List[str] = field(default_factory=list)  # Binding sites
    affinity: float = 0.5  # Binding strength (0-1)
    state: AntibodyState = AntibodyState.NAIVE
    response_type: ResponseType = ResponseType.NEUTRALIZE
    generation: int = 0  # Evolution generation
    parent_id: Optional[str] = None
    created_at: float = field(default_factory=time.time)
    last_activated: Optional[float] = None
    activation_count: int = 0
    success_count: int = 0
    mutation_rate: float = 0.1


@dataclass
class AntibodyResponse:
    """Response generated by an antibody"""
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    antibody_id: str = ""
    threat_id: str = ""
    response_type: ResponseType = ResponseType.NEUTRALIZE
    binding_strength: BindingStrength = BindingStrength.NONE
    effectiveness: float = 0.0
    actions: List[str] = field(default_factory=list)
    timestamp: float = field(default_factory=time.time)


@dataclass
class ClonalExpansion:
    """Tracks clonal expansion of successful antibodies"""
    parent_id: str
    clone_ids: List[str] = field(default_factory=list)
    expansion_factor: int = 1
    started_at: float = field(default_factory=time.time)
    trigger_antigen_id: Optional[str] = None


# ============================================================================
# Antibody Generator
# ============================================================================

class AntibodyGenerator:
    """
    Generates and evolves antibodies for threat response.

    Features:
    - Random antibody generation for novel threats
    - Clonal selection for successful antibodies
    - Somatic hypermutation for affinity improvement
    - Memory cell formation for rapid future response

    Example:
        generator = AntibodyGenerator()

        # Generate antibody for threat
        antibody = generator.generate_antibody(threat)

        # Create response
        response = generator.create_response(antibody, threat)

        # If successful, expand clonally
        if response.effectiveness > 0.8:
            generator.clonal_expansion(antibody, factor=5)
    """

    def __init__(
        self,
        mutation_rate: float = 0.1,
        clonal_expansion_threshold: float = 0.7,
        max_antibodies: int = 1000,
        memory_retention: float = 0.95
    ):
        self.mutation_rate = mutation_rate
        self.clonal_expansion_threshold = clonal_expansion_threshold
        self.max_antibodies = max_antibodies
        self.memory_retention = memory_retention

        # Antibody repertoire
        self.antibodies: Dict[str, Antibody] = {}
        self.memory_cells: Dict[str, Antibody] = {}

        # Antigen database
        self.known_antigens: Dict[str, Antigen] = {}

        # Response history
        self.response_history: List[AntibodyResponse] = []
        self.expansions: List[ClonalExpansion] = []

        # Statistics
        self.generation_count = 0
        self.total_responses = 0

        # Callbacks
        self._callbacks: Dict[str, List[Callable]] = {
            "antibody_generated": [],
            "antibody_activated": [],
            "memory_formed": [],
            "expansion_triggered": []
        }

        # Initialize germline antibodies
        self._initialize_germline()

    def _initialize_germline(self):
        """Initialize germline (default) antibodies"""
        germline_specs = [
            ("corruption_ab", {ThreatType.CORRUPTION}, "corrupt|invalid",
             ResponseType.NEUTRALIZE),
            ("intrusion_ab", {ThreatType.INTRUSION}, "unauthorized|breach",
             ResponseType.SIGNAL),
            ("malicious_ab", {ThreatType.MALICIOUS_INPUT}, "malicious|attack",
             ResponseType.NEUTRALIZE),
            ("exhaustion_ab", {ThreatType.RESOURCE_EXHAUSTION}, "overflow|exhausted",
             ResponseType.COMPLEMENT),
            ("cascade_ab", {ThreatType.CASCADE_FAILURE}, "cascade|spread",
             ResponseType.OPSONIZE),
        ]

        for name, targets, pattern, response in germline_specs:
            self._create_germline_antibody(name, targets, pattern, response)

    def _create_germline_antibody(
        self,
        name: str,
        targets: Set[ThreatType],
        pattern: str,
        response_type: ResponseType
    ) -> Antibody:
        """Create a germline antibody"""
        ab = Antibody(
            name=name,
            target_types=targets,
            binding_pattern=pattern,
            paratope=pattern.split('|'),
            affinity=0.5,  # Moderate affinity
            state=AntibodyState.NAIVE,
            response_type=response_type,
            generation=0
        )
        self.antibodies[ab.id] = ab
        return ab

    def register_antigen(self, threat: Threat) -> Antigen:
        """Register a threat as an antigen"""
        # Check if we've seen this antigen before
        for antigen in self.known_antigens.values():
            if (antigen.threat_type == threat.type and
                antigen.signature == threat.signature):
                antigen.encounter_count += 1
                return antigen

        # Create new antigen
        antigen = Antigen(
            threat_type=threat.type,
            signature=threat.signature,
            epitopes=self._extract_epitopes(threat),
            virulence=self._calculate_virulence(threat)
        )
        self.known_antigens[antigen.id] = antigen
        return antigen

    def _extract_epitopes(self, threat: Threat) -> List[str]:
        """Extract binding epitopes from threat"""
        epitopes = []

        # Use signature
        if threat.signature:
            epitopes.append(threat.signature[:16])

        # Use type
        epitopes.append(threat.type.value)

        # Extract from details
        if threat.details:
            for key, value in threat.details.items():
                if isinstance(value, str) and len(value) < 50:
                    epitopes.append(f"{key}:{value[:20]}")

        return epitopes

    def _calculate_virulence(self, threat: Threat) -> float:
        """Calculate threat virulence"""
        severity_map = {
            ThreatSeverity.LOW: 0.2,
            ThreatSeverity.MEDIUM: 0.4,
            ThreatSeverity.HIGH: 0.7,
            ThreatSeverity.CRITICAL: 1.0
        }
        return severity_map.get(threat.severity, 0.5)

    def find_matching_antibodies(
        self,
        threat: Threat,
        min_affinity: float = 0.3
    ) -> List[Tuple[Antibody, float]]:
        """Find antibodies that match a threat"""
        matches = []

        antigen = self.register_antigen(threat)

        # Check memory cells first (faster response)
        for ab in self.memory_cells.values():
            affinity = self._calculate_binding_affinity(ab, antigen)
            if affinity >= min_affinity:
                matches.append((ab, affinity))

        # Check active antibodies
        for ab in self.antibodies.values():
            if ab.state not in [AntibodyState.EXHAUSTED, AntibodyState.RETIRED]:
                affinity = self._calculate_binding_affinity(ab, antigen)
                if affinity >= min_affinity:
                    matches.append((ab, affinity))

        # Sort by affinity
        matches.sort(key=lambda x: x[1], reverse=True)
        return matches

    def _calculate_binding_affinity(
        self,
        antibody: Antibody,
        antigen: Antigen
    ) -> float:
        """Calculate binding affinity between antibody and antigen"""
        affinity = 0.0

        # Type matching
        if antigen.threat_type in antibody.target_types:
            affinity += 0.3

        # Pattern matching
        import re
        if antibody.binding_pattern:
            try:
                if re.search(antibody.binding_pattern, antigen.signature, re.IGNORECASE):
                    affinity += 0.3
            except re.error:
                if antibody.binding_pattern.lower() in antigen.signature.lower():
                    affinity += 0.2

        # Epitope matching
        matching_epitopes = 0
        for paratope in antibody.paratope:
            for epitope in antigen.epitopes:
                if paratope.lower() in epitope.lower() or epitope.lower() in paratope.lower():
                    matching_epitopes += 1

        if antigen.epitopes:
            epitope_score = matching_epitopes / len(antigen.epitopes)
            affinity += epitope_score * 0.4

        # Apply antibody's intrinsic affinity
        affinity *= antibody.affinity

        return min(1.0, affinity)

    def generate_antibody(
        self,
        threat: Threat,
        force_new: bool = False
    ) -> Antibody:
        """Generate an antibody for a threat"""
        self.generation_count += 1

        # Try to find existing matching antibody
        if not force_new:
            matches = self.find_matching_antibodies(threat, min_affinity=0.5)
            if matches:
                antibody, _ = matches[0]
                self._activate_antibody(antibody)
                return antibody

        # Generate new antibody
        antigen = self.register_antigen(threat)

        antibody = Antibody(
            name=f"ab_{threat.type.value}_{self.generation_count}",
            target_types={threat.type},
            binding_pattern=self._generate_binding_pattern(antigen),
            paratope=antigen.epitopes.copy(),
            affinity=0.5 + random.random() * 0.3,  # Random starting affinity
            state=AntibodyState.ACTIVATED,
            response_type=self._select_response_type(threat),
            generation=1
        )

        self.antibodies[antibody.id] = antibody

        # Trigger callbacks
        for callback in self._callbacks["antibody_generated"]:
            callback(antibody)

        # Manage repertoire size
        self._prune_repertoire()

        return antibody

    def _generate_binding_pattern(self, antigen: Antigen) -> str:
        """Generate a binding pattern for an antigen"""
        patterns = [antigen.threat_type.value]

        # Add signature-based patterns
        if antigen.signature:
            # Extract substrings
            sig = antigen.signature
            if len(sig) >= 4:
                patterns.append(sig[:4])
            if len(sig) >= 8:
                patterns.append(sig[:8])

        # Add epitope patterns
        patterns.extend(antigen.epitopes[:3])

        return '|'.join(set(patterns))

    def _select_response_type(self, threat: Threat) -> ResponseType:
        """Select appropriate response type for threat"""
        type_responses = {
            ThreatType.CORRUPTION: ResponseType.NEUTRALIZE,
            ThreatType.INTRUSION: ResponseType.SIGNAL,
            ThreatType.MALICIOUS_INPUT: ResponseType.NEUTRALIZE,
            ThreatType.RESOURCE_EXHAUSTION: ResponseType.COMPLEMENT,
            ThreatType.ANOMALY: ResponseType.OPSONIZE,
            ThreatType.CASCADE_FAILURE: ResponseType.COMPLEMENT,
            ThreatType.POISONING: ResponseType.NEUTRALIZE,
        }

        return type_responses.get(threat.type, ResponseType.NEUTRALIZE)

    def _activate_antibody(self, antibody: Antibody):
        """Activate an antibody"""
        antibody.state = AntibodyState.ACTIVATED
        antibody.last_activated = time.time()
        antibody.activation_count += 1

        for callback in self._callbacks["antibody_activated"]:
            callback(antibody)

    def create_response(
        self,
        antibody: Antibody,
        threat: Threat
    ) -> AntibodyResponse:
        """Create a response using an antibody"""
        self.total_responses += 1

        antigen = self.register_antigen(threat)
        affinity = self._calculate_binding_affinity(antibody, antigen)

        # Determine binding strength
        binding = self._affinity_to_binding(affinity)

        # Calculate effectiveness
        effectiveness = affinity * (1.0 - antigen.virulence * 0.3)

        # Generate actions based on response type
        actions = self._generate_actions(antibody.response_type, threat)

        response = AntibodyResponse(
            antibody_id=antibody.id,
            threat_id=threat.id,
            response_type=antibody.response_type,
            binding_strength=binding,
            effectiveness=effectiveness,
            actions=actions
        )

        self.response_history.append(response)

        # Update antibody success rate
        if effectiveness > self.clonal_expansion_threshold:
            antibody.success_count += 1

        return response

    def _affinity_to_binding(self, affinity: float) -> BindingStrength:
        """Convert affinity score to binding strength"""
        if affinity < 0.1:
            return BindingStrength.NONE
        elif affinity < 0.3:
            return BindingStrength.WEAK
        elif affinity < 0.5:
            return BindingStrength.MODERATE
        elif affinity < 0.7:
            return BindingStrength.STRONG
        elif affinity < 0.9:
            return BindingStrength.VERY_STRONG
        else:
            return BindingStrength.PERFECT

    def _generate_actions(
        self,
        response_type: ResponseType,
        threat: Threat
    ) -> List[str]:
        """Generate specific actions for response"""
        actions = []

        if response_type == ResponseType.NEUTRALIZE:
            actions.extend([
                f"block_{threat.type.value}",
                "terminate_threat",
                "restore_state"
            ])
        elif response_type == ResponseType.OPSONIZE:
            actions.extend([
                f"mark_{threat.id[:8]}",
                "flag_for_removal",
                "increase_priority"
            ])
        elif response_type == ResponseType.COMPLEMENT:
            actions.extend([
                "trigger_cascade",
                "amplify_response",
                "recruit_effectors"
            ])
        elif response_type == ResponseType.SIGNAL:
            actions.extend([
                "send_alert",
                "notify_systems",
                f"report_{threat.severity.value}"
            ])
        elif response_type == ResponseType.MEMORY:
            actions.extend([
                "store_signature",
                "update_patterns",
                "archive_threat"
            ])

        return actions

    def clonal_expansion(
        self,
        antibody: Antibody,
        factor: int = 5,
        antigen_id: Optional[str] = None
    ) -> List[Antibody]:
        """Clonally expand a successful antibody"""
        clones = []

        expansion = ClonalExpansion(
            parent_id=antibody.id,
            expansion_factor=factor,
            trigger_antigen_id=antigen_id
        )

        for i in range(factor):
            # Create clone with potential mutations
            clone = self._mutate_antibody(antibody)
            clone.parent_id = antibody.id
            clone.generation = antibody.generation + 1

            self.antibodies[clone.id] = clone
            clones.append(clone)
            expansion.clone_ids.append(clone.id)

        self.expansions.append(expansion)

        # Trigger callback
        for callback in self._callbacks["expansion_triggered"]:
            callback(antibody, clones)

        return clones

    def _mutate_antibody(self, parent: Antibody) -> Antibody:
        """Create a mutated clone of an antibody"""
        clone = Antibody(
            name=f"{parent.name}_m{random.randint(1, 999)}",
            target_types=parent.target_types.copy(),
            binding_pattern=parent.binding_pattern,
            paratope=parent.paratope.copy(),
            affinity=parent.affinity,
            state=AntibodyState.NAIVE,
            response_type=parent.response_type,
            generation=parent.generation + 1,
            parent_id=parent.id,
            mutation_rate=parent.mutation_rate
        )

        # Apply mutations
        if random.random() < self.mutation_rate:
            # Mutate affinity (somatic hypermutation)
            delta = random.gauss(0, 0.1)
            clone.affinity = max(0.1, min(1.0, clone.affinity + delta))

        if random.random() < self.mutation_rate * 0.5:
            # Mutate paratope
            if clone.paratope:
                idx = random.randint(0, len(clone.paratope) - 1)
                original = clone.paratope[idx]
                # Small mutation to binding site
                if len(original) > 2:
                    pos = random.randint(0, len(original) - 1)
                    chars = list(original)
                    chars[pos] = chr(ord(chars[pos]) ^ random.randint(1, 26))
                    clone.paratope[idx] = ''.join(chars)

        return clone

    def form_memory_cell(self, antibody: Antibody) -> bool:
        """Convert a successful antibody to a memory cell"""
        if antibody.success_count < 2:
            return False

        antibody.state = AntibodyState.MEMORY

        # Move to memory cells
        self.memory_cells[antibody.id] = antibody
        if antibody.id in self.antibodies:
            del self.antibodies[antibody.id]

        # Trigger callback
        for callback in self._callbacks["memory_formed"]:
            callback(antibody)

        return True

    def affinity_maturation(
        self,
        antigen: Antigen,
        rounds: int = 3
    ) -> Optional[Antibody]:
        """
        Perform affinity maturation to evolve better antibodies.

        Simulates germinal center reactions where antibodies are
        mutated and selected for improved binding.
        """
        # Find best current match
        matches = []
        for ab in self.antibodies.values():
            if ab.state not in [AntibodyState.EXHAUSTED, AntibodyState.RETIRED]:
                affinity = self._calculate_binding_affinity(ab, antigen)
                if affinity > 0:
                    matches.append((ab, affinity))

        if not matches:
            return None

        matches.sort(key=lambda x: x[1], reverse=True)
        best_ab, best_affinity = matches[0]

        # Perform maturation rounds
        for _ in range(rounds):
            # Generate mutants
            mutants = [self._mutate_antibody(best_ab) for _ in range(5)]

            # Select best mutant
            best_mutant = None
            best_mutant_affinity = best_affinity

            for mutant in mutants:
                affinity = self._calculate_binding_affinity(mutant, antigen)
                if affinity > best_mutant_affinity:
                    best_mutant = mutant
                    best_mutant_affinity = affinity

            if best_mutant:
                # Add successful mutant to repertoire
                self.antibodies[best_mutant.id] = best_mutant
                best_ab = best_mutant
                best_affinity = best_mutant_affinity

        return best_ab

    def _prune_repertoire(self):
        """Prune antibody repertoire to maintain size limit"""
        if len(self.antibodies) <= self.max_antibodies:
            return

        # Score antibodies
        scores = []
        for ab in self.antibodies.values():
            score = ab.affinity * 0.3
            score += ab.success_count * 0.2
            score += (1.0 if ab.state == AntibodyState.ACTIVATED else 0.1) * 0.2

            # Recent activation bonus
            if ab.last_activated:
                age = time.time() - ab.last_activated
                score += max(0, 1 - age / 3600) * 0.3

            scores.append((ab.id, score))

        # Remove lowest scoring
        scores.sort(key=lambda x: x[1])
        to_remove = len(self.antibodies) - self.max_antibodies

        for ab_id, _ in scores[:to_remove]:
            ab = self.antibodies[ab_id]
            # Check if should become memory cell
            if ab.success_count >= 2 and random.random() < self.memory_retention:
                self.form_memory_cell(ab)
            else:
                del self.antibodies[ab_id]

    def get_statistics(self) -> Dict[str, Any]:
        """Get antibody system statistics"""
        return {
            "total_antibodies": len(self.antibodies),
            "memory_cells": len(self.memory_cells),
            "known_antigens": len(self.known_antigens),
            "total_responses": self.total_responses,
            "generation_count": self.generation_count,
            "expansion_count": len(self.expansions),
            "antibody_states": {
                state.value: len([ab for ab in self.antibodies.values()
                                 if ab.state == state])
                for state in AntibodyState
            },
            "response_types": {
                rt.value: len([ab for ab in self.antibodies.values()
                              if ab.response_type == rt])
                for rt in ResponseType
            },
            "average_affinity": np.mean([ab.affinity for ab in self.antibodies.values()])
                if self.antibodies else 0.0
        }


# ============================================================================
# Example Usage
# ============================================================================

if __name__ == "__main__":
    print("Antibody System Demo")
    print("=" * 50)

    # Create generator
    generator = AntibodyGenerator(mutation_rate=0.15)

    print(f"\n1. Initial state:")
    stats = generator.get_statistics()
    print(f"   Antibodies: {stats['total_antibodies']}")
    print(f"   Memory cells: {stats['memory_cells']}")

    # Create test threats
    threats = [
        Threat(type=ThreatType.CORRUPTION, severity=ThreatSeverity.HIGH,
               signature="corrupt_data_001", details={"file": "config.yaml"}),
        Threat(type=ThreatType.INTRUSION, severity=ThreatSeverity.CRITICAL,
               signature="unauthorized_access", details={"ip": "192.168.1.1"}),
        Threat(type=ThreatType.MALICIOUS_INPUT, severity=ThreatSeverity.MEDIUM,
               signature="sql_injection_attempt", details={"query": "SELECT *"})
    ]

    print("\n2. Generating antibodies for threats...")
    for threat in threats:
        ab = generator.generate_antibody(threat)
        response = generator.create_response(ab, threat)
        print(f"   Threat: {threat.type.value}")
        print(f"     Antibody: {ab.name}")
        print(f"     Affinity: {ab.affinity:.2f}")
        print(f"     Response: {response.response_type.value}")
        print(f"     Effectiveness: {response.effectiveness:.2f}")

    print("\n3. Testing clonal expansion...")
    # Get a successful antibody
    successful_ab = list(generator.antibodies.values())[0]
    successful_ab.success_count = 3

    clones = generator.clonal_expansion(successful_ab, factor=3)
    print(f"   Created {len(clones)} clones from {successful_ab.name}")
    for clone in clones:
        print(f"     Clone: {clone.name}, affinity={clone.affinity:.2f}")

    print("\n4. Testing memory cell formation...")
    if generator.form_memory_cell(successful_ab):
        print(f"   Memory cell formed: {successful_ab.name}")
    else:
        print("   Memory cell formation failed")

    print("\n5. Testing affinity maturation...")
    antigen = list(generator.known_antigens.values())[0]
    matured = generator.affinity_maturation(antigen, rounds=5)
    if matured:
        print(f"   Matured antibody: {matured.name}")
        print(f"   Final affinity: {matured.affinity:.2f}")

    print("\n6. Final statistics:")
    stats = generator.get_statistics()
    print(f"   Total antibodies: {stats['total_antibodies']}")
    print(f"   Memory cells: {stats['memory_cells']}")
    print(f"   Known antigens: {stats['known_antigens']}")
    print(f"   Average affinity: {stats['average_affinity']:.2f}")
