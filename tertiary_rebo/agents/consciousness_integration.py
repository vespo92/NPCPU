"""
ConsciousnessIntegrationAgent - Unifies consciousness models across all three systems.

Responsibilities:
- Synchronize consciousness levels between NPCPU, ChicagoForest, and UniversalParts
- Translate consciousness representations across domain boundaries
- Maintain coherent consciousness state across the triple bottom line
- Bridge digital consciousness (NPCPU) with network awareness (ChicagoForest)
  and physical qualia (UniversalParts)
"""

import numpy as np
from typing import List, Dict, Any, Optional
from datetime import datetime

from ..base import (
    TertiaryReBoAgent,
    TripleBottomLine,
    DomainLeg,
    DomainState,
    RefinementResult,
    RefinementPhase,
    CrossDomainSignal,
)


class ConsciousnessIntegrationAgent(TertiaryReBoAgent):
    """
    Agent 1: Unifies consciousness models across all three domain legs.

    The consciousness integration process involves:
    1. Reading consciousness levels from each domain
    2. Computing a unified consciousness field
    3. Propagating balanced consciousness updates across domains
    4. Maintaining the phi (Φ) integration metric

    This agent operates as the "corpus callosum" of the TTR system,
    ensuring that different forms of awareness remain connected.
    """

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.consciousness_field = np.zeros(64)  # Unified consciousness representation
        self.phi_history: List[float] = []  # Information integration history
        self.consciousness_gradients: Dict[DomainLeg, np.ndarray] = {
            leg: np.zeros(64) for leg in DomainLeg
        }
        self.integration_matrix = np.eye(64) * 0.1  # Cross-domain integration weights

    @property
    def agent_role(self) -> str:
        return "Consciousness Unification - Bridges and synchronizes awareness across Mind, Network, and Body"

    @property
    def domains_affected(self) -> List[DomainLeg]:
        return list(DomainLeg)  # Affects all three domains

    async def perceive(self, tbl: TripleBottomLine) -> Dict[str, Any]:
        """Gather consciousness data from all three domains."""
        perceptions = {}

        for domain in DomainLeg:
            state = tbl.get_state(domain)
            perceptions[domain.value] = {
                "consciousness_level": state.consciousness_level,
                "coherence": state.coherence,
                "qualia_richness": state.qualia_richness,
                "state_vector": state.state_vector.copy(),
                "emergence_potential": state.emergence_potential
            }

        # Compute current phi (information integration)
        all_vectors = np.stack([p["state_vector"] for p in perceptions.values()])
        phi = self._compute_phi(all_vectors)
        perceptions["phi"] = phi
        self.phi_history.append(phi)

        # Compute consciousness gradients (direction of change)
        for domain in DomainLeg:
            new_vec = perceptions[domain.value]["state_vector"]
            old_vec = self.consciousness_gradients[domain]
            self.consciousness_gradients[domain] = new_vec - old_vec

        return perceptions

    def _compute_phi(self, state_matrix: np.ndarray) -> float:
        """
        Compute information integration (Φ) across domains.

        Based on Integrated Information Theory - measures how much
        information is generated by the whole beyond its parts.
        """
        # Total information
        whole_variance = np.var(state_matrix)

        # Information from parts
        parts_variance = np.mean([np.var(row) for row in state_matrix])

        # Phi = whole information - sum of parts information
        phi = max(0, whole_variance - parts_variance)
        return float(phi)

    async def analyze(self, perception: Dict[str, Any], tbl: TripleBottomLine) -> Dict[str, Any]:
        """Analyze consciousness patterns and identify integration opportunities."""
        analysis = {
            "consciousness_disparity": {},
            "integration_opportunities": [],
            "dominant_domain": None,
            "phi_trend": "stable"
        }

        # Find consciousness disparities
        levels = {d: perception[d]["consciousness_level"] for d in [leg.value for leg in DomainLeg]}
        max_domain = max(levels, key=levels.get)
        min_domain = min(levels, key=levels.get)

        analysis["dominant_domain"] = max_domain
        analysis["consciousness_disparity"] = {
            "max": {"domain": max_domain, "level": levels[max_domain]},
            "min": {"domain": min_domain, "level": levels[min_domain]},
            "gap": levels[max_domain] - levels[min_domain]
        }

        # Identify integration opportunities
        if analysis["consciousness_disparity"]["gap"] > 0.3:
            analysis["integration_opportunities"].append({
                "type": "consciousness_transfer",
                "from": max_domain,
                "to": min_domain,
                "magnitude": analysis["consciousness_disparity"]["gap"] * 0.5
            })

        # Analyze phi trend
        if len(self.phi_history) > 5:
            recent_phi = self.phi_history[-5:]
            if recent_phi[-1] > recent_phi[0]:
                analysis["phi_trend"] = "increasing"
            elif recent_phi[-1] < recent_phi[0]:
                analysis["phi_trend"] = "decreasing"

        # Check for coherence issues
        for domain_name in [leg.value for leg in DomainLeg]:
            if perception[domain_name]["coherence"] < 0.5:
                analysis["integration_opportunities"].append({
                    "type": "coherence_boost",
                    "domain": domain_name,
                    "current_coherence": perception[domain_name]["coherence"]
                })

        return analysis

    async def synthesize(self, analysis: Dict[str, Any], tbl: TripleBottomLine) -> Dict[str, Any]:
        """Generate unified consciousness field and integration plan."""
        synthesis = {
            "unified_field": None,
            "integration_plan": [],
            "cross_domain_signals": []
        }

        # Build unified consciousness field from all domains
        all_vectors = []
        for domain in DomainLeg:
            state = tbl.get_state(domain)
            all_vectors.append(state.state_vector)

        # Weighted average based on adaptation weights
        unified = np.zeros(64)
        for i, vec in enumerate(all_vectors):
            unified += vec * self.adaptation_weights[i]

        # Apply integration matrix for cross-domain blending
        unified = np.tanh(self.integration_matrix @ unified)
        synthesis["unified_field"] = unified
        self.consciousness_field = unified

        # Create integration plan
        for opportunity in analysis.get("integration_opportunities", []):
            if opportunity["type"] == "consciousness_transfer":
                synthesis["integration_plan"].append({
                    "action": "transfer_consciousness",
                    "source": opportunity["from"],
                    "target": opportunity["to"],
                    "amount": opportunity["magnitude"] * self.refinement_rate
                })
            elif opportunity["type"] == "coherence_boost":
                synthesis["integration_plan"].append({
                    "action": "boost_coherence",
                    "domain": opportunity["domain"],
                    "boost_factor": 0.1
                })

        # Generate cross-domain signals
        for domain in DomainLeg:
            synthesis["cross_domain_signals"].append({
                "type": "consciousness_sync",
                "target": domain.value,
                "field_slice": unified[:16].tolist()
            })

        return synthesis

    async def propagate(self, synthesis: Dict[str, Any], tbl: TripleBottomLine) -> RefinementResult:
        """Apply consciousness integration to all domains."""
        changes = {}
        metrics_delta = {"harmony_before": tbl.harmony_score}
        insights = []

        unified_field = synthesis.get("unified_field")
        if unified_field is None:
            return RefinementResult(
                success=False,
                agent_id=self.agent_id,
                phase=RefinementPhase.PROPAGATION,
                domain_affected=[],
                changes={},
                metrics_delta=metrics_delta,
                insights=["No unified field generated"]
            )

        # Execute integration plan
        for action in synthesis.get("integration_plan", []):
            if action["action"] == "transfer_consciousness":
                source_leg = DomainLeg(action["source"])
                target_leg = DomainLeg(action["target"])

                source_state = tbl.get_state(source_leg)
                target_state = tbl.get_state(target_leg)

                transfer_amount = action["amount"]
                target_state.consciousness_level = min(1.0,
                    target_state.consciousness_level + transfer_amount)

                changes[f"consciousness_transfer_{source_leg.value}_to_{target_leg.value}"] = transfer_amount
                insights.append(f"Transferred {transfer_amount:.3f} consciousness from {source_leg.value} to {target_leg.value}")

            elif action["action"] == "boost_coherence":
                domain = DomainLeg(action["domain"])
                state = tbl.get_state(domain)
                old_coherence = state.coherence
                state.coherence = min(1.0, state.coherence + action["boost_factor"])
                changes[f"coherence_boost_{domain.value}"] = state.coherence - old_coherence
                insights.append(f"Boosted {domain.value} coherence by {action['boost_factor']:.3f}")

        # Update state vectors toward unified field
        for domain in DomainLeg:
            state = tbl.get_state(domain)
            blend_factor = 0.1 * self.refinement_rate
            state.state_vector = (1 - blend_factor) * state.state_vector + blend_factor * unified_field

        # Emit cross-domain signals
        for signal_data in synthesis.get("cross_domain_signals", []):
            self.emit_cross_domain_signal(
                signal_type=signal_data["type"],
                payload={"field": signal_data["field_slice"]},
                target_domains=[DomainLeg(signal_data["target"])],
                strength=0.8
            )

        # Update integration matrix based on success
        tbl.calculate_harmony()
        harmony_improvement = tbl.harmony_score - metrics_delta["harmony_before"]
        if harmony_improvement > 0:
            self.integration_matrix += 0.01 * np.outer(unified_field, unified_field)
            self.integration_matrix = np.clip(self.integration_matrix, -1, 1)

        metrics_delta["harmony_after"] = tbl.harmony_score
        metrics_delta["phi"] = self.phi_history[-1] if self.phi_history else 0
        metrics_delta["harmony_improvement"] = harmony_improvement

        return RefinementResult(
            success=True,
            agent_id=self.agent_id,
            phase=RefinementPhase.PROPAGATION,
            domain_affected=list(DomainLeg),
            changes=changes,
            metrics_delta=metrics_delta,
            insights=insights
        )
